Используем Vim в качестве IDE для Erlang
23 января 2013

Вот уже более трех лет я пишу код исключительно в vim. Не дано мне понять, что всем так нравится в этих Emacs, Eclipse, IntelliJ IDEA и прочих. Зачем они нужны, если старый добрый vim (который, я полагаю, вам все равно иногда приходится использовать) можно за пять минут превратить в хорошую, годную IDE для любого языка?

Возьмем, к примеру, расширение vimerl. Устанавливается оно следующим образом:

wget http://www.vim.org/scripts/download_script.php?src_id=17542 \
  -O vimerl-1.4.1.tar.gz
tar -xvzf vimerl-1.4.1.tar.gz
mv vimerl-1.4.1 ~/.vim/vimerl
В ~/.vimrc прописываем:

set runtimepath+=$HOME/.vim/vimerl
autocmd Filetype erlang setlocal omnifunc=erlang_complete#Complete
Также нам понадобится пакет erlang-manpages:

sudo apt-get install erlang-manpages
Запускаем vim, читаем справку по плагину:

:helptags ~/.vim/vimerl/doc/
:help vimerl
Теперь у нас есть автодополнение для имен функций, воспользоваться которым можно, нажав Ctr+X, Ctr+O в режиме редактирования:

Vim в качестве IDE для Erlang

Имена функций ищутся по-умному, с просмотром каталогов src и deps, парсингом rebar.config и тд. Также нам доступно автодополнение по ключевым словам (Ctr+P или Ctr+N), которое удобно использовать для имен переменных и модулей. Это, а также фолдинг, нумерация строк, вкладки и многое другое, есть в vim и без плагинов.

Vimerl автоматически расставляет за вас отступы. Поправить отступы в уже написанном коде можно, выделив его и нажав =. Чтобы прочитать справку по модулю, наводим курсор на имя модуля и нажимаем Shift+K. Также мы можем создавать скелеты модулей. Например, команда :ErlangGenServer создает скелет gen_server‘а. При этом имя модуля автоматически определяется по имени файла.

Допустим, нам нужно быстро перейти к определению функции, на которой сейчас находится курсор. Для решения этой задачи нам понадобится ctags (тот, что установлен в системе по умолчанию, скорее всего, является плохим, негодным ctags):

sudo apt-get install ctags
Индексируем файлы с исходным кодом:

ctags -R ./src ./deps/*/src
Перезапускаем vim или просто говорим:

:set tags+=tags
Теперь, чтобы перейти к определению функции, наводим на нее курсор и нажимаем Ctr+]. Для возврата назад по стеку переходов нажимаем Ctr+T. Чтобы открыть определение функции в новой вкладке, нужно нажать Ctr+W, Ctr+], Ctr+W, Shift+T. Чтобы постоянно не вводить эту довольно длинную последовательность, прописываем в ~/.vimrc:

nmap <C-p> <C-w><C-]><C-w>T
Однако половина мощи vim заключается в возможности легко использовать его совместно со сторонними утилитами. Мне не нужно, чтобы в vim был поиск по файлам, интеграция с системой управления версиями или некой системой сборки, потому что я могу сказать :!grep -rE pattern, :!git commit -am '...' или :!rebar compile. А в сочетании с оконным менеджером i3 и оболочкой zsh получается просто шикарная среда для разработки.

Конечно, в чем-то vim может уступать другим IDE и редакторам. Например, в нем нет той фишки из Sublime Text с редактированием нескольких строк одновременно (или я просто о ней не знаю). И сложный рефакторинг кода на Erlang с переименованием половины модулей и функций в vim, возможно, произвести не так просто, как в неком другом редакторе. Зато vim, например, не просит платить за него денег, нигде не тормозит и может быть с легкостью запущен удаленно по SSH. Плюс он есть «из коробки» в большинстве *nix систем, пусть и без специализированных расширений типа vimerl.

А в чем вы пишите код? Какие возможности IDE/редактора нравятся вам больше всего?

Дополнение: Оказалось, что (1) vimerl намного удобнее устанавливается при помощи Pathogen и (2) сам vimerl можно брать из этого репозитория на GitHub. Vimerl умеет подсвечивать cтроки, содержащие ошибки. Получить список ошибок можно командой :cl. Переходить между строками, содержащими ошибки, удобно при помощи окна с ошибками, которое открывается командой :copen. Помимо vimerl есть замечательный плагин erlang-motions, обязательно ознакомьтесь с ним! Также при программировании на Erlang вы просто обязаны использовать sync. Только не забудьте в корне репозитория завести run.sh, потому что в embedded режиме (см также тынц) sync не работает.

Дополнение: См также инструкцию по настройке Vim для программирования на Erlang от Martin Logan, одного из авторов книги «Erlang and OTP in Action».

Метки: Erlang, Разработка, Функциональное программирование.